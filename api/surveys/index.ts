// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";
import { Context, HttpRequest } from "@azure/functions";
const { TableClient } = require("@azure/data-tables");
import { v4 as uuidv4 } from 'uuid';
import { OnBehalfOfCredentialAuthConfig, OnBehalfOfUserCredential, UserInfo } from "@microsoft/teamsfx";

interface Response {
  status: number;
  body: { [key: string]: any } | string;
}

type TeamsfxContext = { [key: string]: any };

function getTableClient(table: string) {
  return TableClient.fromConnectionString(
    process.env.DatabaseStorage,
    table
  );
}

async function getSurveys() {
  const tableClient = getTableClient("surveys")

  let surveys = [];
  for await (const survey of await tableClient.listEntities()) {
    surveys.push(survey);
  }

  surveys = surveys.sort((a, b) => (new Date(a.createdAt) > new Date(b.createdAt)) ? 1 : -1);

  // Initialize response.
  const res: Response = {
    status: 200,
    body: Array.from(surveys),//(({ id, enabled, last_run }) => ({ id, enabled, last_run }))(surveyData),
  };
  
  return res;
}

async function createSurvey(context: Context, req: HttpRequest, teamsfxContext: TeamsfxContext) {
  const tableClient = getTableClient("surveys")


  const newSurvey = {
    partitionKey: "0", // Use tennant name?
    rowKey: uuidv4(),
    topic: req.body.topic,
    questions: JSON.stringify(req.body.questions), // Arrays not supported in table storage
    status: 'PENDING',
    createdAt: new Date().toISOString(),
    createdBy: await getUserEmail(context, teamsfxContext),
  };

  await tableClient.createEntity(newSurvey);

  const res: Response = {
    status: 201,
    body: newSurvey,
  };

  return res;  
}

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - new OnBehalfOfUserCredential(accessToken, oboAuthConfig) - Construct OnBehalfOfUserCredential instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClientWithCredential() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log(req.method + ' - ' + req.url);

  //TODO Check the users access rights 
  console.log(JSON.stringify(context))
  console.log(JSON.stringify(teamsfxContext))


  switch (req.method) {
    case "GET":
      return getSurveys();
    case "POST":
      return createSurvey(context, req, teamsfxContext);
    default:
      return {
        status: 400,
        body: "Invalid request",
      };
    }
}

async function getUserEmail(context: Context, teamsfxContext: TeamsfxContext) {

  // Prepare access token.
  const accessToken: string = teamsfxContext["AccessToken"];
  if (!accessToken) {
    return "No access token was found in request header."
  }

  const oboAuthConfig: OnBehalfOfCredentialAuthConfig = {
    authorityHost: process.env.M365_AUTHORITY_HOST,
    clientId: process.env.M365_CLIENT_ID,
    tenantId: process.env.M365_TENANT_ID,
    clientSecret: process.env.M365_CLIENT_SECRET,
  };
  
  let oboCredential: OnBehalfOfUserCredential;
  
  try {
    oboCredential = new OnBehalfOfUserCredential(accessToken, oboAuthConfig);
  } catch (e) {
    return "Failed to construct OnBehalfOfUserCredential using your accessToken. " +
          "Ensure your function app is configured with the right Azure AD App registration."
  }

  //TODO Look up UPN and store that instead?

  // Query user's information from the access token.
  try {
    const currentUser: UserInfo = await oboCredential.getUserInfo();
    console.log(currentUser.objectId)
    if (currentUser && currentUser.preferredUserName) {
      return currentUser.preferredUserName
    } else {
      return "No user information was found in access token."
    }
  } catch (e) {
    context.log.error(e);
    return  "Access token is invalid."
  }
}
