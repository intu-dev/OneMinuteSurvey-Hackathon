/* This code sample provides a starter kit to implement server side logic for your Teams App in TypeScript,
 * refer to https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference for complete Azure Functions
 * developer guide.
 */

// Import polyfills for fetch required by msgraph-sdk-javascript.
import "isomorphic-fetch";
import { Context, HttpRequest } from "@azure/functions";
import { Client } from "@microsoft/microsoft-graph-client";
import {
  createMicrosoftGraphClientWithCredential,
  OnBehalfOfCredentialAuthConfig,
  OnBehalfOfUserCredential,
  UserInfo,
} from "@microsoft/teamsfx";
const { TableClient } = require("@azure/data-tables");

interface Response {
  status: number;
  body: { [key: string]: any };
}

type TeamsfxContext = { [key: string]: any };

function getTableClient(table: string) {
  return TableClient.fromConnectionString(process.env.DatabaseStorage, table);
}

/**
 * This function handles requests from teamsfx client.
 * The HTTP request should contain an SSO token queried from Teams in the header.
 * Before trigger this function, teamsfx binding would process the SSO token and generate teamsfx configuration.
 *
 * This function initializes the teamsfx SDK with the configuration and calls these APIs:
 * - new OnBehalfOfUserCredential(accessToken, oboAuthConfig) - Construct OnBehalfOfUserCredential instance with the received SSO token and initialized configuration.
 * - getUserInfo() - Get the user's information from the received SSO token.
 * - createMicrosoftGraphClientWithCredential() - Get a graph client to access user's Microsoft 365 data.
 *
 * The response contains multiple message blocks constructed into a JSON object, including:
 * - An echo of the request body.
 * - The display name encoded in the SSO token.
 * - Current user's Microsoft 365 profile if the user has consented.
 *
 * @param {Context} context - The Azure Functions context object.
 * @param {HttpRequest} req - The HTTP request.
 * @param {teamsfxContext} TeamsfxContext - The context generated by teamsfx binding.
 */
export default async function run(
  context: Context,
  req: HttpRequest,
  teamsfxContext: TeamsfxContext
): Promise<Response> {
  context.log("getSurveyResponses()");

  //TODO Check the users access rights

  var surveyId = context.bindingData.surveyId;

  const responseTableClient = getTableClient("surveyResponses");
  const surveyTableClient = getTableClient("surveys");
  const questionsTableClient = getTableClient("questions");

  const survey = await surveyTableClient.getEntity("0", surveyId);

  // Load the survey's questions
  const questionIds = JSON.parse(survey.questions);
  const questionCount = questionIds.length;

  const questions = [];
  const questionIdMap = new Map();

  for (let i = 0; i < questionCount; i++) {
    const question = await questionsTableClient.getEntity(
      "0",
      `${questionIds[i]}`
    );
    questions.push(question.category);
    questionIdMap.set(questionIds[i], i);
  }

  // Load the survey's responses
  const filter = `PartitionKey eq '${surveyId}'`;
  const surveyResponseIter = await responseTableClient.listEntities({
    queryOptions: { filter: filter },
  });

  const questionMap = new Map();

  // Populate the question response map
  for (let i = 0; i < questionCount; i++) {
    questionMap.set(i, { min: 999, max: -1, responses: new Map() });
  }

  for await (const response of surveyResponseIter) {
    let questionInfo = questionMap.get(questionIdMap.get(response.questionId));

    if (questionInfo.responses.has(response.userId)) {
      context.log(
        `Error - duplicate response found for user ${response.userId}, survey ${surveyId}.`
      );
    } else {
      questionInfo.responses.set(response.userId, response.response);

      if (response.response > questionInfo.max) {
        questionInfo.max = response.response;
      }
      if (response.response < questionInfo.min) {
        questionInfo.min = response.response;
      }
    }
  }

  for (let i = 0; i < questionCount; i++) {
    const questionInfo = questionMap.get(i);
    let sum = 0;
    questionInfo.responses.forEach((v, k) => {
      sum += Number(v);
    });
    questionInfo.avg = sum / questionInfo.responses.size;
  }

  const results = [
    { name: "Maximum", values: new Array(questionCount) },
    { name: "Average", values: new Array(questionCount) },
    { name: "Minimum", values: new Array(questionCount) },
  ];

  for (const [id, questionData] of questionMap) {
    results[0].values[id] = questionData.max;
    results[1].values[id] = questionData.avg;
    results[2].values[id] = questionData.min;
  }

  const res: Response = {
    status: 200,
    body: {
      surveyId,
      questions,
      responseCount: questionMap.get(0).responses.size,
      results,
    },
  };

  return res;
}
